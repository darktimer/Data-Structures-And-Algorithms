[TOC]



## 线性表

线性就是有着前后关系。非线性就是不是简单的前后关系。

**随机访问：**数组的线性表性质、在内存中连续存储相同数据类型的性质，使得其具备了根据数组下标随机访问的性质。

删除数组中的元素时，为了维持数组的**内存连续性**，需要把后面的数据一次搬移到前边，否则会出现空洞，破坏连续性。但有些时候并不一定非得追求数据连续性，可以把删除操作集中在一起执行，又或是假装删除，设置一个标记，标记那些需要删除的元素，等数组的空间不够了，再进行一次真正的删除操作。这和 JVM 的标记清除垃圾回收算法的核心思想十分类似

## 警惕数组越界访问

```
int main(int argc, char* argv[]){    
	int i = 0;
	int arr[3] = {0};
	for(; i<=3; i++){
		arr[i] = 0;
		printf("hello world\n");
	}
	return 0;
}
```

在 C 中，只要不是受限的内存，所有的内存空间是可以自由访问的，如果不小心在数组中访问了越界位置，而这个位置又恰巧存储了一个会引起逻辑错误的值，就会引发未知的后果。有些计算机病毒就是利用数组越界访问非法地址攻击系统的。JAVA 中会自动抛出越界异常。

JAVA 中的 ArrayList 容器类，支持动态扩容、封装数组操作细节，比 C 中的数组要有些许优势，但也存在劣势，动态扩容意味着要申请内存和搬移数据，这些是耗时的有损性能的，最好还是在开始就指定数据所需的内存大小。

需要在性能和省时省力之间做平衡，如果重点是处理业务，那么用 ArrayList 这种容器类是比较方便的，但是如果要开发框架，做底层开发，追求性能优化，那么还是用数组会好点。

局部变量在存储中的结构是一个栈，上面的代码，局部变量 i 和数组首地址 arr 很可能在栈中是相邻位置，且 i 的地址在 arr 的前边，假设这里的编译器在分配内存时采用了递减的方式，当 arr 访问越界后，因为 i 在 arr 首地址前边，那么很可能越界后访问的非法地址会回到 i ，然后导致这个循环无限执行下去。

## 为什么数组从 [0] 开始编号

其实数组的下标最确切的定义是偏移 offset ，数组名是数组在内存中的首地址，a[0] 也就是偏移为 0 的位置，而随机访问依靠的数组下标，实际上是根据首地址 a[0] 和待访问下标计算的偏移量得出的，即公式：

a[k]_address = bass_address + k * type_size

如果从 1 开始计算，那么公式变为：

a[k]_address = bass_address + ( k - 1 ) * type_size

多了一次减法运算，对于 CPU 来说多了一条减法指令。数组是一种非常基础的数据结构，最好做到性能优化到最大程度。

但这些也只是一方面的原因，从 0 开始编号也有历史原因等等甚至还有些不是那么严肃的原因，总之记住就好。

P.S. python 的数组下标可以是负数。