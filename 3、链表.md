

[TOC]

## 常见缓存淘汰算法

先进先出策略 FIFO 、最少使用策略 LFU 、最近最少使用策略 LRU 。 LRU 是需要用代码熟练实现的。

## 链表和数组对比

**存储结构：数组** 要求内存必须提供  **一定大小 **且 **地址连续** 的空间，两个条件必须同时满足才能申请成功。链表不需要连续空间，而是通过指针串联零散的内存块，另外，只需要内存有足够大小满足即可申请成功。

## 常见链表结构

单链表、循环链表、双向链表。

<img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom: 50%;" />

**单链表：** 单链表中有两个节点比较特殊，一个是头结点，一个是尾节点。头结点记录的是链表的基地址，尾节点指向一个空地址 NULL 。链表没有随机访问的特性，只能通过头结点逐个元素遍历，时间复杂度是 O(n) ，但删除和插入操作都非常方便，时间复杂度是 O(1) 。

<img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt="img" style="zoom:50%;" />

**循环链表：** 循环链表和单链表的唯一不同就是，循环链表的尾节点不指向空地址，而是指向头结点，这样的结构在处理具有环型的数据时十分适用。

<img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom: 50%;" />

------

**双向链表：** 双向链表在实际开发中比较常用，因为强。它比单链表多了一个存储空间，存储指向前一个节点的 prev 和指向后一个节点的 next ，因此在寻找前驱和后继节点时的时间复杂度能达到 O(1) ，但是，同样的删除和插入等操作，使用双向链表就比单链表性能要好。

比如删除操作，为了寻找给定值在链表中的位置，单链表和双向链表都需要从头结点开始一个一个遍历，时间复杂度都是 O(n) ，找到目标节点后开始执行删除操作，但是删除一个节点，需要知道这个节点的前驱节点，所以又得遍历一次整个链表，这时区别就来了，单链表需要再一次遍历链表寻找前驱，付出 O(n) 的代价，而双向链表只需要 prev 就能找到前驱节点，只需付出 O(1) 。插入操作同理。

对于查找来说也差不多，查找给定值，对于一个有序的双向链表来说，可以记住上次查找的位置，需要做的就是对比给定值和上次位置的值，来决定是向后还是向前查找，平均只需要找一半的数据。

